# [2020q1](http://wiki.csie.ncku.edu.tw/linux/schedule) 第 1 週測驗題
###### tags: `linux2020`

:::info
目的: 檢驗學員對 **[linked list](https://hackmd.io/s/SkE33UTHf)** 的認知
:::

---
### 測驗 `1`

**觀察:**

這是一個遞迴函式，開頭聲明了中斷的條件:
```cpp
if (!start || !start->next)
    return start;
```

如果程式沒有中斷，則會遞迴的對輸入的節點，以及輸入節點的下一個節點，分別遞迴呼叫函式，我稱其為子呼叫。兩個子呼叫，會保證

```cpp
left = sort(left)
right = sort(right)
```
之後，left 跟 right 指向一個已經排序好的串列。當子呼叫結束之後，開始進入排序的主體，也就是 for loop 。

**解題思路:**

**觀察 LL0 選項:**

(b) 會造成每次 ```sort(left)``` 進入無窮迴圈，刪去。
(c) 會把 left 跟 right 指向同個位置，```sort(left)``` 與 ```sort(right)``` 都是排序 right 以後的節點，雖不無可能，但違反寫程式的常理，暫不考慮。

(a) 將 start->next 後的節點排序好，並使 left 與 right 斷開。(d) 將 start->next 後的節點排序好，並使 left 指向排序好的第二個元素(次小的)。先保留 (a) (d) 往下看。

**觀察 ```(right == NULL || (left && left->data < right->data))```**

```(left && left->data < right->data)```
這個條件在判斷左節點與右節點的相對大小是否正確，至此可以猜測 LL0 應該要選 (a) 把 left 跟 right 斷開，並且由判斷式決定尋找 left 在排序好的 right 串列中的插入點 (insertion sort)。

觀察 LL1, LL4 的選項都不會更改 left, right 的值，所以 LL1, LL4 應該至少要初始化 merge ，要不然會陷入無窮迴圈。 且 LL1, LL4 是唯一可以決定回傳值的選項，可以推論LL1 是 ```start = merge = left``` ， LL4 是 ```start = merge = right```。

如果進入 LL4 或 LL5 ，意味著 right 並非 left 正確的插入點，因此 LL5 應該是 ```merge->next = right``` 而且 LL6 應該是 ```right = right->next``` 來尋找下一個插入點。

找到插入點之後會進入 LL2 -> LL3 ，此時應該要在 merge 與 right 之間插入 left，所以 LL2 是 ```merge->next = left```。在看 LL3 的選項之後，發現唯一一個可能就只剩下 ```left = left->next``` 這一步實際上等於是把 left 設為 NULL ，下一次迴圈的時候才會進入 LL6 把剛剛的插入點連接上 right 。

---
回顧完整的程式碼為:

```cpp
list *sort(list *start) {
    if (!start || !start->next)
        return start;
    list *left = start;
    list *right = left->next;
    left->next = NULL;

    left = sort(left);
    right = sort(right);

    for (list *merge = NULL; left || right;) {
        if (right == NULL || (left && left->data < right->data)) {
            if (!merge) {
                start = merge = left;
            }
            else {
                merge->next = left;
                merge = merge->next;
            }
            left = left->next;
        }
        else {
            if (!merge) {
                start = merge = right;
            } else {
                merge->next = right;
                merge = merge->next;
            }
            right = right->next;
        }
    }
    return start;
}
```
了解程式碼的行為的關鍵是
0. 這是一個遞迴涵式， ```sort(right)``` 保證將 ```start->next``` 排序好，而 #6 截斷 start (也是 left)，並使 #8 沒有意義。
1. ```(right == NULL || (left && left->data < right->data))``` 在尋找 start (也是 left) 正確的插入點。
2. 沒有找到插入點的話， merge 跟 right 會往右移動一步。
3. 找到正確的插入點時， #17-#18 會把插入點的左邊連結到 start ，但是右邊依然處在斷列的狀態。將 start 串上 right 是靠
 ```left = left->next;``` 將 left 設為 NULL ，並在下一次迴圈時進入 ```merge->next = right``` 接上的。
4. 一旦接上之後，會反覆跑 #26-#29 直到 right 為 NULL 為止。

---
:::success
延伸問題:
1. 解釋上述程式運作原理;
2. 指出程式改進空間，特別是考慮到 [Optimizing merge sort](https://en.wikipedia.org/wiki/Merge_sort#Optimizing_merge_sort);
3. 將上述 singly-linked list 擴充為 circular doubly-linked list 並重新實作對應的 `sort`;
4. 依循 Linux 核心 [include/linux/list.h](https://github.com/torvalds/linux/blob/master/include/linux/list.h) 程式碼的方式，改寫上述排序程式;
5. 嘗試將原本遞迴的程式改寫為 iterative 版本;
:::
