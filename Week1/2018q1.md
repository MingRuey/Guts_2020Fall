# 2018q1 Homework (quiz4)

- ==[Linked List 練習題](https://hackmd.io/s/SyK-WApKM)==
- [參考解題錄影](https://www.youtube.com/watch?v=zaA9jzWvMlg&list=PLFSyL7YoFilT_HugG5YUnSqslvFrwuIEp)

### **測驗1**
![](https://i.imgur.com/I4mcQ7d.png)

### Q1. 分析以下程式碼，推敲 FuncA, FuncB, FuncC 的作用，並且推測程式執行結果。 <font size="1">(假設條件： malloc 總是成功而且返回的記憶體空間可讀寫) </font>

[2018q1](https://hackmd.io/@jserv/SyK-WApKM?)

---
#### FuncA 的作用是?

- 先粗看程式碼的結構，以if block 為界分成兩個部分:
```cpp=
if (!*start) {
    ...
    return
}
...
```
如果 dereference start 是 NULL (註: NULL, 0 和 Point: [Stack Overflow](https://stackoverflow.com/questions/1296843/what-is-the-difference-between-null-0-and-0) 也可參考 C99 6.5.3.3 P5 和 6.3.2.3 P3)，則:

```text
┌ start = new_node ┐
|                  |
--------><----------
```
即 new_node 變成一個只有單一節點的 double linkeed list (且 data 的值為 val)，並將 start 指向他。

如果 dereference start 不為 NULL ，則假設原本的 start 長這樣:
```
 node Last <-- start --> node Next
           -->       <--*
```
變成:
```
 node Last <-- new_node <-- start --> node N
           -->          -->       <--*
```
即在一個既有的 double linked list 的節點 start 前插入一個新的節點 (且 data 的值為 val) 所以 FuncA 的作用就是創造一個節點，如果輸入的節點 (start) 已經存在，就接在 start 前面， 否則將 start 指向新創造的節點，並且該節點為此 double linked list 唯一的元素。

因為輸入的變數名稱稱之為 start，將之定義為 double linked list 的 "開頭" 的話，答案會是 (e) ，新創的節點為 double linked list 的結尾。

---
#### 2. FuncB 的作用是?
在執行到 #7 為止，都跟 FuncA 很像:
```
last->next = (*start)->prev = new_node;
```

假設原本的 start 連結長這樣:
```
 node Last <-- start --> node Next
           -->       <--*
```
(到 Line 7 為止) 新的連結會長這樣:
```
 node Last <-- new_node <-- start --> node N
           -->          -->       <--*
```
但是 Line 8 將 start 的值指向 new_node:
```
*start = new_node
```

也就是 double linked list 的頭重新被指向到剛剛新創立的節點，答案是 (d)。

---
#### FuncC 的作用是?

一開始建立一個值為 value1 新節點，接著搜尋值為 value2 的節點，如果不幸找不到程式碼就會停留在迴圈裡出不來。找到的話， #6~#10 會把剛剛的新節點加在搜尋到的節點後面，所以答案是 (e)。

---

#### 在程式輸出中，訊息 Traversal in forward direction 後依序印出哪幾個數字呢？

```
FuncA(&start, 51); FuncB(&start, 48);
FuncA(&start, 72); FuncA(&start, 86);
FuncC(&start, 63, 51);
```
在上述一連串操作之後，目前的 linked list 內容如下:

start=48 --> 51 --> 63 --> 72 --> 86
         <--    <--    <--    <--

所以從 start 開始，依序為 48, 51, 63, 72 和 86，注意到 86 是在 #6 印出的。

---
#### 在程式輸出中，訊息 Traversal in reverse direction 後依序印出哪幾個數字呢？

同上，但 forloop 從 86 往 72 方向走，依序為 86, 72, 63, 51, 48。

:::
延伸題目：
* 在上述 doubly-linked list 實作氣泡排序和合併排序，並提出需要額外實作哪些函示才足以達成目標

:notes: 參考實作
* [merge sort](https://github.com/LinYunWen/c-review/blob/master/week4/merge_sort.c)
* [bubble sort](https://github.com/LinYunWen/c-review/blob/master/week4/bubble_sort.c)
:::

### Q2 考慮以下程式碼，推敲程式作用並分析輸出。<font size=1>(假設條件： malloc 總是成功而且返回的記憶體空間可讀寫 malloc() 得到的地址成嚴格單調遞增函數)</font>

![](https://i.imgur.com/vIk5eO9.png)

[2018q1](https://hackmd.io/@jserv/SyK-WApKM?)

---
#### 1. FuncX 的作用是 (涵蓋程式執行行為的正確描述最多者)?

#3 的 for loop 終止條件會讓 node 離開迴圈之後，要嘛是 NULL ，要嘛是 head ，兩者我們分開考慮:

在 node 是 NULL 離開的情況下，他會回傳 NULL - head ，其行為可以參考 Q1 FuncA 的討論。

而在 node 是 head 的情況下，也就是一個 linked list 是環狀的，這時候會回傳值是 0。

不論是何者，過程中每走訪一個非 head 或非 NULL 的節點，都會造成 data 的值增加 sizeof(int)，但 data 只是一個 local variable ，不影響使用者輸入參數的值，因此答案是 (e)。

---
#### 2. K1 >> 後面接的輸出為何
#### 3. K2 >> 後面接的輸出為何
#### 4. K3 >> 後面接的輸出為何
#### 5. K4 >> 後面接的輸出為何
#### 6. K5 >> 後面接的輸出為何
#### 7. count >> 後面接的輸出為何

分析 main() 函式:

```cpp
struct node *head = node_new(0);
head->next = node_new(1);
head->next->next = node_new(2);
head->next->next->next = node_new(3);
head->next->next->next->next = node_new(4);
```
執行完狀態為

head=0 --> 1 -->  2 --> 3 --> 4

所以此時 head 不為環狀， FuncX(head, &count) 的輸出不為零，所以答案為 "Yes" 。

```cpp
head->next->next->next->next = head;
```
將 linked list 的 3 節點連回 head，得到:

head=0 --> 1 -->  2 --> 3 --> head

此時 linked list 為環形，所以 K2 會輸出 "No"。

```cpp
head->next->next->next->next->next = head->next;
```
賦值左邊的為 0 節點的 next ，右邊亦為 0 節點的 next ，所以操作之後結果不變， K3 一樣為 "No" 。

```cpp
head->next = head->next->next->next->next->next->next->next->next;
```

賦值左邊的為 0 節點的 next ，右邊為 3 點的 next ，也就是 0 節點，所以操作之後結果 head 會指向自己。觀察 FuncX 在 linked list 只有單一節點的行為是回傳 0 ，所以 K4 輸出為 no ， K5 為 0 。

count 的行為可參考 FuncX 的分析，使用者輸入並不會被改動，因此他的值跟依然跟初始值一樣是 0 。
