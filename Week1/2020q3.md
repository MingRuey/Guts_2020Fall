# 2020q3 Homework1 (quiz1)
contributed by < `MingRuey` >

### **測驗1**

程式運作原理
---

### **add_entry**
---
先創造一個值為 new_value 的節點之後，用 assert 檢查新節點是否創成功。
> :warning: TODO: 研究為什麼 assert 在 ```new_node->value``` , ```new_node->next``` 賦值後面，而不是前面，這樣的寫法在 mallloc 失敗的時候行為是什麼?

接著理解如何用 pointer to pointer 在 linked list 的尾巴擺上剛剛創造的節點:

首先我們有個串列
```graphviz
digraph init{
    rankdir=LR;
    node [shape=record];
    1 [label="{<address>&1|node 1|{value|next}|{1|<ref>&2}}"];
    2 [label="{<address>&2|node 2|{value|next}|{2|<ref>&3}}"];
    3 [label="{<address>&3|node 3|{value|next}|{...|<ref>}}"];
    1:ref -> 2:address [color=black];
    2:ref -> 3:address [color=black];
}
```

接著研究 while 迴圈的判斷式 ```*indirect```，*indirect 的型態是 pointer *node_t ，在一開始 *indirect 會取出 head 的地址:

```graphviz
digraph indirect{
    rankdir=LR;
    node [shape=record];
    1 [label="{<address>&1|node 1|{value|next}|{1|<ref>&2}}"];
    2 [label="{<address>&2|node 2|{value|next}|{2|<ref>&3}}"];
    3 [label="{<address>&3|node 3|{value|next}|{...|<ref>}}"];
    1:ref -> 2:address [color=black];
    2:ref -> 3:address [color=black];
    indirect [label="{indirect|**head\n=&(*node1)}"]
    indirect -> 1:address [color=red];
}
```

接著來看 ```indirect = &(*indirect)->next``` 一行， ```(*indirect)->next``` 的型態是 pointer *node ，指向 pseudo pointer 的 next ， & operator 使得 **indirect 的值為 next 地址** :

```graphviz
digraph indirect_next{
    rankdir=LR;
    node [shape=record];
    1 [label="{<address>&1|node 1|{value|<next>next}|{1|<ref>&2}}"];
    2 [label="{<address>&2|node 2|{value|next}|{2|<ref>&3}}"];
    3 [label="{<address>&3|node 3|{value|next}|{...|<ref>}}"];
    1:ref -> 2:address [color=black];
    2:ref -> 3:address [color=black];
    
    indirect [label="{indirect|&((&node1)\-\>next)}"]
    indirect -> 1:next [color=red];
}
```

這個過程會反覆到 *indirect 為 null pointer 為止，也就是如下圖的狀況:

```graphviz
digraph endgame{
    rankdir=LR;
    node [shape=record];
    last [label="{<address>&|node ...|{value|next}|{...|<ref>&end}}"];
    end [label="{<address>&end|node end|{value|<next>next}|{...|<ref>null}}"];
    last:ref -> end:address [color=black];
    
    indirect [label="{indirect|&((&end)\-\>next)}"]
    indirect -> end:next [color=red];
}
```

離開迴圈之後， ```*indirect = new_node``` 讓 indirect 的內容，也就是 end 的 next 更新為新創造的 new_node，完成新增節點在結尾:

```graphviz
digraph endgame{
    rankdir=LR;
    node [shape=record];
    last [label="{<address>&|node ...|{value|next}|{...|<ref>&end}}"];
    end [label="{<address>&end|node end|{value|<next>next}|{...|<ref>&new}}"];
    new [label="{<address>&new|node new|{value|next}|{...|<ref>null}}"];
    
    last:ref -> end:address [color=black];
    end:ref -> new:address [color=black];
    
    indirect [label="{indirect|&((&end)\-\>next)}"]
    indirect -> end:next [color=red];
}
```

### **find_entry**
---
find_entry 的運作相對來說比較簡單，一開始 current 指向 head 的地址:
```graphviz
digraph indirect{
    rankdir=LR;
    node [shape=record];
    1 [label="{<address>&1|node 1|{value|next}|{1|<ref>&2}}"];
    2 [label="{<address>&2|node 2|{value|next}|{2|<ref>&3}}"];
    3 [label="{<address>&3|node 3|{value|next}|{...|<ref>}}"];
    1:ref -> 2:address [color=black];
    2:ref -> 3:address [color=black];
    current [label="{current|*head\n=&node1}"]
    current -> 1:address [color=red];
}

```

接著研究 for loop 終止的條件 ```current && current->value != value``` 也就是 current 是 null pointer 或是 current 就是要尋找的值，搭配每圈 ```current = current->next``` 的更新，在 ```current->value == value``` 的情況下，會回傳當前的節點:

```graphviz
digraph indirect{
    rankdir=LR;
    node [shape=record];
    1 [label="{<address>&1|node 1|{value|next}|{1|<ref>&2}}"];
    2 [label="{<address>&2|node 2|{value|next}|{2|<ref>&3}}"];
    3 [label="{<address>&3|node 3|{value|next}|{...|<ref>}}"];
    1:ref -> 2:address [color=black];
    2:ref -> 3:address [color=black];
    current [label="{current|&2\n=回傳值}"]
    current -> 2:address [color=red];
}
```
另外一種情況則是 current 為 null pointer 跳出迴圈，也就是已經遍歷了整個串列的情況，此時就會回傳 null pointer:
```graphviz
digraph indirect{
    rankdir=LR;
    node [shape=record];
    previous [label="{<address>&...|node ...|{value|next}|{...|<ref>&end}}"];
    end [label="{<address>&end|node end|{value|next}|{end|<ref>null}}"];
    previous:ref -> end:address [color=black];
    
    current [label="{current|null\n=回傳值}"]
    current -> end:ref [color=red];
}
```

### **remove_entry**
---
...


**swap_pair**
...

**reverse**
...

:::success
延伸問題:

函式 swap_pair 和 reverse 對於指標的操作方式顯然異於 add_entry 及 remove_entry，需要額外做 head = ... 的更新，請用指標的指標來改寫，並避免回傳指標;

以遞迴改寫上述的 reverse，注意，你可能因此需要建立新的函式，如 rev_recursive，隨後在 reverse 函式中呼叫 rev_recursive;

針對 singly-linked list 的節點，實作 Fisher–Yates shuffle，你應該儘量降低記憶體的使用量;
:::