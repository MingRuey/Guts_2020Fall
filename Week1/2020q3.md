# 2020q3 Homework1 (quiz1)
contributed by < `MingRuey` >

### **測驗1**

程式運作原理
---

**add_entry**

先創造一個值為 new_value 的節點之後，用 assert 檢查新節點是否創成功。
> :warning: TODO: 研究為什麼 assert 在 ```new_node->value``` , ```new_node->next``` 賦值後面，而不是前面，這樣的寫法在 mallloc 失敗的時候行為是什麼?

接著理解如何用 pointer to pointer 在 linked list 的尾巴擺上剛剛創造的節點:

首先我們有個串列
```graphviz
digraph init{
    rankdir=LR;
    node [shape=record];
    1 [label="{<address>&1|node 1|{value|next}|{1|<ref>}}"];
    2 [label="{<address>&2|node 2|{value|next}|{2|<ref>}}"];
    3 [label="{<address>&3|node 3|{value|next}|{...|<ref>}}"];
    1:ref -> 2:address [color=black];
    2:ref -> 3:address [color=black];
}
```

接著研究 while 迴圈的判斷式 ```*indirect```， *indirect 的型態是 pointer *node_t ，我們以一個假想的 pseudo pointer 圖示化 *indirect 的值:

```graphviz
digraph indirect{
    rankdir=LR;
    node [shape=record];
    1 [label="{<address>&1|node 1|{value|next}|{1|<ref>&1}}"];
    2 [label="{<address>&2|node 2|{value|next}|{2|<ref>&2}}"];
    3 [label="{<address>&3|node 3|{value|next}|{...|<ref>}}"];
    1:ref -> 2:address [color=black];
    2:ref -> 3:address [color=black];
    p [label="{&\n=indirect|pointer pseudo\n=*indirect|{value}|<to>&1}"];
    p:to -> 1:address [color=red];
}
```

接著來看 ```indirect = &(*indirect)->next``` 一行， ```(*indirect)->next``` 的型態是 pointer *node ，指向 pseudo pointer 的 next ，所以這行會將 indirect 的內容指向 pseudo pointer 的 next 的 address 圖中的 pseudo_next :

```graphviz
digraph indirect_next{
    rankdir=LR;
    node [shape=record];
    1 [label="{<address>&1|node 1|{value|next}|{1|<ref>&2}}"];
    2 [label="{<address>&2|node 2|{value|next}|{2|<ref>&3}}"];
    3 [label="{<address>&3|node 3|{value|next}|{...|<ref>}}"];
    1:ref -> 2:address [color=black];
    2:ref -> 3:address [color=black];
    
    p [label="{&\n=indirect|pointer pseudo|{value}|<to>&1}"]; 
    p:to -> 1:address [color=red];
    next [label="{&|pointer pseudo_next\n=(*indirect)\-\>next\n=pseudo\-\>next|{value}|<to>&2}"];
    next:to -> 2:address [color=red];
}
```

這個過程會反覆到 *indirect 為 null pointer 為止，也就是如下圖的狀況:

```graphviz
digraph endgame{
    rankdir=LR;
    node [shape=record];
    last [label="{<address>&|node ...|{value|next}|{...|<ref>&end}}"];
    end [label="{<address>&end|node end|{value|next}|{...|<ref>}}"];
    null [label="{null}"];
    last:ref -> end:address [color=black];
    end:ref -> null:address [color=black];
    p [label="{&\n=indirect|pointer pseudo\n=*indirect|{value}|<to>null}"];
    p:to -> null [color=red];
}
```

離開迴圈之後， ```*indirect = new_node``` 讓 indirect 的內容，也就是 end 的 next 更新為新創造的 new_node，完成新增節點在結尾:

```graphviz
digraph endgame{
    rankdir=LR;
    node [shape=record];
    last [label="{<address>&|node ...|{value|next}|{...|<ref>}}"];
    end [label="{<address>&end|node end|{value|next}|{...|<ref>}}"];
    new [label="{<address>&new|node new|{value|next}|{...|<ref>}}"];
    null [label="{null}"];
    
    last:ref -> end:address [color=black];
    end:ref -> new:address [color=black];
    new:ref -> null [color=black];
    p [label="{pointer pseudo\n=*indirect|{value}|<to>&new}"];
    p:to -> new:address [color=red];
}
```


**remove_entry**
...

**swap_pair**
...

**reverse**
...

:::success
延伸問題:

函式 swap_pair 和 reverse 對於指標的操作方式顯然異於 add_entry 及 remove_entry，需要額外做 head = ... 的更新，請用指標的指標來改寫，並避免回傳指標;

以遞迴改寫上述的 reverse，注意，你可能因此需要建立新的函式，如 rev_recursive，隨後在 reverse 函式中呼叫 rev_recursive;

針對 singly-linked list 的節點，實作 Fisher–Yates shuffle，你應該儘量降低記憶體的使用量;
:::